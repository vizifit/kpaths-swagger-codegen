
buildscript {
    repositories {
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "io.swagger:swagger-codegen:2.3.1"
        classpath "com.moowork.gradle:gradle-node-plugin:1.2.0"
    }
}

plugins {
    id 'java'
    id 'groovy'
    id "de.undercouch.download" version "3.3.0"
    id "com.moowork.node" version "1.2.0"
}

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'com.moowork.node'

repositories {
    mavenCentral()
}

import org.gradle.api.tasks.Exec
import org.apache.tools.ant.taskdefs.condition.Os

ext {
    spring_boot_version = '1.5.6.RELEASE'
    jackson_version = '2.4.2'
    jersey_version = '1.18'
    jodatime_version = '2.3'
    junit_version = '4.8.1'
    swagger_codegen_version ='2.3.1'
    npmCommand = Os.isFamily(Os.FAMILY_WINDOWS) ? 'npm.cmd' : 'npm'
    bowerCommand = Os.isFamily(Os.FAMILY_WINDOWS) ? 'bower.cmd' : 'bower'
}

defaultTasks  'generateCode'

version = '1.0.1'
group = 'org.kp.cccs.kpaths'
 
def kpathCodegenPath = './configuration/kpaths-swagger-config.json'
def kpathCodegen
 

// Tasks
task initConfiguration {

    delete(buildDir)

    def jsonFile = file(kpathCodegenPath)
    kpathCodegen = new groovy.json.JsonSlurper().parseText(jsonFile.text)

    def bumpVersion = kpathCodegen.config.kpaths.bumpVersion

    // Update Component version & configuration
    if(bumpVersion){
        updateComponentBuildVersion(kpathCodegen, kpathCodegenPath) 

        jsonFile = file(kpathCodegenPath)
        kpathCodegen = new groovy.json.JsonSlurper().parseText(jsonFile.text)
    }
}

def beautifyJsonFile(filePath){

    def jsonFile = file(filePath) 
    def slurped = new groovy.json.JsonSlurper().parseText(jsonFile.text)
    def builder = new groovy.json.JsonBuilder(slurped)

     // Write updated configuration
    jsonFile.withWriter( 'UTF-8' ) { it << builder.toPrettyString() }
}
task generateCode {

    prepareForBuild(kpathCodegen)
    downloadSpecificationFiles(kpathCodegen)
    generateClientApiLibrary(kpathCodegen)
}


def prepareForBuild(kpathCodegen){ 
    wrapComment("line", "${kpathCodegen.config.name} Version: ${kpathCodegen.config.version}")

    println "Cleaning up build directory...\n" 
}


def buildFileName(componentKey, kpathCodegen) {

    def specDir = kpathCodegen.config.swagger.dir.clientSpec
    def specSuffix = kpathCodegen.config.swagger.client.suffix.specification
    def filename = "${specDir}/${componentKey + specSuffix}.json"

    println "Creating filename for: " + filename + "..."

    return filename
}

def wrapComment(type, comment ){ 
    switch (type){

        case  "line":
            println "\n------------------------------------"
            println "${comment}"
            println "--------------------------------------\n"
            break
    } 
}

def downloadSpecificationFiles(kpathCodegen){
 
    def componentList = kpathCodegen.config.kpaths.componentList

    wrapComment("line", "START: Downloading specification files...")

    
    // Loop through specification data
    for ( component in componentList ) {

        def filename = buildFileName(component.key.toLowerCase(), kpathCodegen)
        if(component.active){
            download {
                src component.endpoint
                dest file( filename ) 
            }

            beautifyJsonFile(filename)
        }
    } 
    wrapComment("line", "COMPLETED: Downloading specification files...") 
}

def getClientRepoRoot(componentKey, kpathCodegen){

    def clientApi = kpathCodegen.config.swagger.dir.clientApi   
    def clientRepoPfx = kpathCodegen.config.swagger.client.prefix.repo    
    def root = "${clientApi}/${clientRepoPfx}${componentKey.toLowerCase()}"
    
    println "getClientRepoRoot: ${root}"
    
    return root
}

def getClientLibRoot(componentKey, kpathCodegen, isRelPath){

    def componentName = componentKey.toLowerCase()
    def clientApi = kpathCodegen.config.swagger.dir.clientApi
    def clientRepoPfx = "${kpathCodegen.config.swagger.client.prefix.repo}${componentName}"     
    def pkgLib = kpathCodegen.config.swagger.client.package.lib 
    def libPrefix = "${pkgLib}/${getClientLibPrefix(componentKey, kpathCodegen)}"
    def root = "${clientApi}/${clientRepoPfx}/${libPrefix}"

    if(isRelPath){
        root = libPrefix  
    }
    
    println "getClientLibRoot: ${root}"

    return root
}
 
def getClientLibPrefix(componentKey, kpathCodegen){
    def libPrefix = "${kpathCodegen.config.swagger.client.prefix.module}-${componentKey.toLowerCase()}"
}

def generateClientApiLibrary(kpathCodegen){
  
    wrapComment("line", "START: Generating Client api... ") 
    def componentList = kpathCodegen.config.kpaths.componentList
     
    // Replace Template values
    for ( component in componentList ) {

        if(component.active){ 

            // Generate code from Swagger logic
            generateSwaggerCode(kpathCodegen, component)

            // Copy Templates and supporting files
            copyProjectTemplateFiles(kpathCodegen, component)

            // Replace Template values
            replaceProjectTemplateFileValues(kpathCodegen, component) 
        }
    } 
    wrapComment("line", "COMPLETED: Generating Client api...")
}

def updateComponentBuildVersion(kpathCodegen, kpathCodegenPath){

    def componentList = kpathCodegen.config.kpaths.componentList
    def bumpVersion = kpathCodegen.config.kpaths.bumpVersion
    def bumpVersionStep = kpathCodegen.config.kpaths.bumpVersionStep

    def jsonFile = file(kpathCodegenPath) 
    def slurped = new groovy.json.JsonSlurper().parseText(jsonFile.text)
    def builder = new groovy.json.JsonBuilder(slurped)
     
    wrapComment("line", "BEGIN: Updating component versions for ${bumpVersionStep}...")
    def counter = 0

    for ( component in componentList ) {
        if(component.active){ 
 
            def versionParts = component.version.split('\\.')
            def updatedVersion = "" 
            def major = versionParts[0]
            def minor = versionParts[1]
            def patch = versionParts[2]

            def updateValue = 0
            switch(bumpVersionStep){

                case "major":
                    updateValue = major as int
                    updateValue++
                    updatedVersion =  "${updateValue}.${minor}.${patch}"
                    break

                case "minor":
                    updateValue = minor as int
                    updateValue++
                    updatedVersion =  "${major}.${updateValue}.${patch}"
                    break

                case "patch":
                    updateValue = patch as int
                    updateValue++
                    updatedVersion =  "${major}.${minor}.${updateValue}"
                    break
            } 
            builder.content.config.kpaths.componentList[ counter ].version = updatedVersion
            println("Bumping ${bumpVersionStep} version from ${component.version} to ${updatedVersion} for component: ${component.key}" )
        }

        counter++
    } 

    // Write updated configuration
    jsonFile.withWriter( 'UTF-8' ) { it << builder.toPrettyString() }
    
    wrapComment("line", "COMPLETED: Updating component versionsUpdating component versions for ${bumpVersionStep}...")
}

def copyProjectTemplateFiles(kpathCodegen, component){
 
    def pkg = kpathCodegen.config.swagger.client.package
    def tmplDir = kpathCodegen.config.templates.dir

    // Manipulate code after SwaggerGeneration
    copyFilestoDirectory( tmplDir.clientRoot, getClientRepoRoot(component.key, kpathCodegen), null ) 
    copyFilestoDirectory( tmplDir.clientSrc, "${getClientRepoRoot(component.key, kpathCodegen)}/${pkg.root}", null ) 
    copyFilestoDirectory( tmplDir.clientSrcApp, "${getClientRepoRoot(component.key, kpathCodegen)}/${pkg.app}", null )

    // Include Gradle Wrapper
    def includeWrapper = kpathCodegen.config.gradle.includeWrapper 
    if(includeWrapper){
        copyFilestoDirectory( tmplDir.gradle, getClientRepoRoot(component.key, kpathCodegen), null )
    }
}


def replaceProjectTemplateFileValues(kpathCodegen, component){

    def pkgSrc = kpathCodegen.config.swagger.client.package.root
    def pkgLibSrc = kpathCodegen.config.swagger.client.package.lib 
    def pkgAppSrc = kpathCodegen.config.swagger.client.package.app   
    def language = kpathCodegen.config.swagger.client.language 
    def libPath =  getClientLibRoot(component.key, kpathCodegen, true) 
    def libPrefix =  getClientLibPrefix(component.key, kpathCodegen)
    def clientRepoRoot = getClientRepoRoot(component.key, kpathCodegen)

    def relLibSrcPath = "${pkgLibSrc}/${libPrefix}"
    def relAppSrcPath = "${pkgAppSrc}"
    def projectName = getClientProjectName(component.key, kpathCodegen, false)
    def projectApiName = getClientProjectName(component.key, kpathCodegen, true)
    def includeWrapper = kpathCodegen.config.gradle.includeWrapper 

    // Public API Export
    def exportReplaceMap =  ["\\./" : "./${relLibSrcPath}/"]
    replaceValuesInFile(component.key, kpathCodegen, "${relLibSrcPath}/index.ts",  exportReplaceMap, "public_api.ts", true)
  
    // Add Content to replaced file 
    addContentToFile(component.key, kpathCodegen, "public_api.ts", "export * from \'./src/app/modules/header/header.module\';" )

    // Angular CLI Template
    def angularCliReplMap =  ["#client-project-name#": projectName,
                                "#client-project-root#": pkgSrc,
                                "#client-project-prefix#": projectName,
                                "#client-lib-prefix#": libPrefix,
                                "#client-lib-source-root#": "${relLibSrcPath}/src"]
    replaceValuesInFile(component.key, kpathCodegen, ".angular-cli.json.template", angularCliReplMap, ".angular-cli.json", false )

    // JSON Package Template
    def jsonPackageReplMap =  ["#client-project-api-name#": projectApiName,
                                "#client-project-version#": component.version,
                                "#client-project-description#": "Swagger [${language}] Client API for KPATHS ${component.key} Component",
                                "#client-project-author#": kpathCodegen.config.author]
    replaceValuesInFile(component.key, kpathCodegen, "package.json.template", jsonPackageReplMap, "package.json", true )

    // Index HTML Template
    def indexHtmlReplMap =  ["#project-description#": "${kpathCodegen.config.name}: ${component.key.toUpperCase()} v${component.version}"]
    replaceValuesInFile(component.key, kpathCodegen, "${pkgSrc}/index.html.template", indexHtmlReplMap, "${pkgSrc}/index.html", true )

    // App Component HTML Template
    def appComponentReplMap =  ["#project-description#": "${kpathCodegen.config.name}: ${component.key.toUpperCase()} v${component.version}"]
    replaceValuesInFile(component.key, kpathCodegen, "${relAppSrcPath}/app.component.html.template", appComponentReplMap, "${relAppSrcPath}/app.component.html", true )
 
    // Swagger Config 
    def apiConfigReplMap =  ["@param": "param",
                                "@returns": "returns"]
    replaceValuesInFile(component.key, kpathCodegen, "${relLibSrcPath}/configuration.ts", apiConfigReplMap, null, true )

    // Replace README.md
    def readMeReplMap =  ["#client-project-api-name#": projectApiName,
                                "#client-project-version#": component.version,
                                "#multiple-api-usage#" : "{ ApiModule as ${component.title}ApiModule from \'${projectApiName}\'"]
    replaceValuesInFile(component.key, kpathCodegen, "README.md.template", readMeReplMap, "README.md", false )


    // Gradle Build Template
    def gradleReplMap =  ["#client-project-name#": libPrefix]

    if(includeWrapper){
        gradleReplMap.put("#default-task#", "defaultTasks \'pack\'")
    }
    
    replaceValuesInFile(component.key, kpathCodegen, "build.gradle.template", gradleReplMap, "build.gradle" , false)
}
 
def addContentToFile(componentKey, kpathCodegen, sourcePath, value ){
 
    def relPath = "${getClientRepoRoot(componentKey, kpathCodegen)}/${sourcePath}" 
    def exportFile = new File(relPath) 
    def fileText = exportFile.text 

    fileText = fileText + "\n" + value

    exportFile.text = fileText 
}

def replaceValuesInFile(componentKey, kpathCodegen, sourcePath, valueMap, moveToPath, isAllValues ){
 
    def rootPath =  getClientRepoRoot(componentKey, kpathCodegen)
    def relPath = "${rootPath}/${sourcePath}" 
    def exportFile = new File(relPath) 
    def fileText = exportFile.text 
    //println "METHOD: replaceValuesInFile ${relPath}"
    //println "FILE TEXT: ${fileText}"

    if(valueMap){
        valueMap.each{ mapKey, mapValue ->  
            //println "${mapKey} : ${mapValue}"  
            if(isAllValues){
                fileText = fileText.replaceAll(mapKey, mapValue)
            }
            else{
                fileText = fileText.replace(mapKey, mapValue)
            }
        }  
    }
    
    //println "FILE TEXT REPLACED: ${fileText}" 
    exportFile.text = fileText 

    if(moveToPath){ 
        exportFile.renameTo( new File("${rootPath}/${moveToPath}") ) 
    } 
}

// def moveFile(sourcePath, targetPath){ 
//     def targetFile = new File(sourcePath) 
//     targetFile.renameTo( new File(targetPath) ) 
// }

import io.swagger.codegen.config.CodegenConfigurator
import io.swagger.codegen.DefaultGenerator
 
def generateSwaggerCode(kpathCodegen, component ){
  
    def pkgLibRoot = ""  
    def language = kpathCodegen.config.swagger.client.language 
    
    // Can use full path for this later; relatie path does not work on windows.
    //def specFilePath = buildFileName(componentKey, kpathCodegen)   
    def outputDir = file(getClientLibRoot(component.key, kpathCodegen, false))
    
    println "\nGenerating Client [${language}] api code for:  ${component.key}"
    println "\nGenerating Client to path: ${outputDir.path}" 
    
    def config = new CodegenConfigurator()
    config.setInputSpec(component.endpoint as String)
    config.setOutputDir(outputDir.path as String)
    config.setLang(language as String)
    config.setAdditionalProperties([
            'invokerPackage': "${pkgLibRoot}" as String,
            'modelPackage'  : "${pkgLibRoot}model" as String,
            'apiPackage'    : "${pkgLibRoot}api" as String,
            'dateLibrary'   : 'java8'
    ])
    // config.setImportMappings([
    //         'Dog': 'io.swagger.petstore.client.model.Dog'
    // ])
 
    new DefaultGenerator().opts(config.toClientOptInput()).generate() 
}

def getClientProjectName(componentKey, kpathCodegen, isTitle){
 
    def clientRepoPfx = kpathCodegen.config.swagger.client.prefix.repo
    def clientTitlePfx = kpathCodegen.config.swagger.client.prefix.title
   
    if(isTitle == true){
        return "${clientTitlePfx}-${componentKey.toLowerCase()}"
    }

    return "${clientRepoPfx}${componentKey.toLowerCase()}"
}
 
 def copyFilestoDirectory(  source, destination, excludeValue){
  
    wrapComment("line", "COPY FILES: From source directory [ ${source}]")

    String sourceDir = source
    String destinationDir = destination

    if(!excludeValue){
        excludeValue = "*.java"
    }

    ant.copy(todir: destinationDir) {
        fileset(dir : sourceDir) {
            exclude(name: excludeValue)
        }
    }

    wrapComment("line", "COPY FILES: To destination directory [ ${destination}]")
}
  
// Get the path for the locally installed binaries
task npmBin << {
    new ByteArrayOutputStream().withStream { os ->
        exec {
            executable = npmCommand
            args = ['bin']
            standardOutput = os
        }
        ext.binPath = os.toString().trim() + File.separator
    }
}

 
def cleanEntireBuildDir(){
    println "CLEANING....${project.buildDir}"
    def dir = new File(project.buildDir)
    if (dir.isDirectory()) {
        ant.delete(includeemptydirs: true) {
            fileset(dir: dir, includes: '**/*', excludes: '')
        }
    }
}
task cleanBuildDir(description: 'Cleans up Build Directory') << {

    cleanEntireBuildDir()
}
  
task buildProjectManifest(type: Copy) {
    from 'templates/project'
    into 'templates/project'
    include 'projectinfo.html.template'
    rename { file -> 'index.html' }
    expand(project: project, title: 'Swagger Project Detail', generated: new Date())
}

configurations {
    swagger
}

sourceSets {
    swagger {
        compileClasspath = configurations.swaggerCompile
        java {
            srcDir file("${project.buildDir.path}/swagger/src/main/java")
        }
    }
    main {
        compileClasspath += swagger.output
        runtimeClasspath += swagger.output
    }
    test {
        compileClasspath += swagger.output
        runtimeClasspath += swagger.output
    }
}

//generateApi.dependsOn(generateFiles)
//compileSwaggerJava.dependsOn generateApi
//classes.dependsOn swaggerClasses
//compileJava.dependsOn compileSwaggerJava
 
 
buildProjectManifest.dependsOn(initConfiguration)
generateCode.dependsOn(buildProjectManifest)
 
dependencies {
    swaggerCompile "org.springframework.boot:spring-boot-starter-web:$spring_boot_version"
    swaggerCompile 'io.swagger:swagger-annotations:1.5.16'
    swaggerCompile 'com.squareup.okhttp:okhttp:2.7.5'
    swaggerCompile 'com.squareup.okhttp:logging-interceptor:2.7.5'
    swaggerCompile 'com.google.code.gson:gson:2.8.1'

    //compile sourceSets.swagger.output

    compile "com.sun.jersey:jersey-client:$jersey_version"
    compile "com.sun.jersey.contribs:jersey-multipart:$jersey_version"
    compile "com.fasterxml.jackson.core:jackson-core:$jackson_version"
    compile "com.fasterxml.jackson.core:jackson-annotations:$jackson_version"
    compile "com.fasterxml.jackson.core:jackson-databind:$jackson_version"
    compile "com.fasterxml.jackson.datatype:jackson-datatype-joda:2.1.5"
    compile "joda-time:joda-time:$jodatime_version"
    compile "io.swagger:swagger-codegen:$swagger_codegen_version"

    testCompile "junit:junit:$junit_version"

    runtime 'com.squareup.okhttp:okhttp:2.7.5'
    runtime 'com.squareup.okhttp:logging-interceptor:2.7.5'
    runtime 'com.google.code.gson:gson:2.8.1'
}

//installDebug -q &> /dev/null
// Required for build configuration arguments (./gradelew installDebug -q &> /dev/null)
//gradle.useLogger(new CustomEventLogger())
//
//class CustomEventLogger extends BuildAdapter implements TaskExecutionListener {
//
//    void beforeExecute(Task task) {
//        println "[$task.name]"
//    }
//
//    void afterExecute(Task task, TaskState state) {
//        println()
//    }
//
//}

// def replaceJsonPackageContent(componentKey, kpathCodegen){

//     def clientApiDir = kpathCodegen.config.swagger.codeGenOutDir  
//     def language = kpathCodegen.config.swagger.clientLanguage 
//     def clientRepoPfx = kpathCodegen.config.swagger.clientRepoPfx   
//     def filePath = "${getClientRepoRoot(componentKey, kpathCodegen)}/package.json"
//     def version = "1.0.0"  // Need code to determine version

//     println "replaceJsonPackageContent: ${filePath}"

//     wrapComment("line", "Updating package.json: ${filePath}")

//     def jsonFile = file(filePath) 
//     def slurped = new groovy.json.JsonSlurper().parseText(jsonFile.text)
//     def builder = new groovy.json.JsonBuilder(slurped)
    
//     builder.content.name = getClientProjectName(componentKey, kpathCodegen, true) //"@Kpaths/client-api-${componentKey.toLowerCase()}"
//     builder.content.version = version
//     builder.content.description = "Swagger [${language}] client for KPATHS ${componentKey} Component"
//     builder.content.author = "Kaiser Permanente CD-BIO Engineering"


//     // Get the new JSON string
//     //String newJson = builder.toPrettyString()

//     // And write it out to the file again
//     jsonFile.withWriter( 'UTF-8' ) { it << builder.toPrettyString() }

// }
